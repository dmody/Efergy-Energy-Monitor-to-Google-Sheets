/* ==========================================================================
   ENERGY MONITOR v5.4 (THE FINAL TURBO MASTER)
   - Fixed: Hourly Log device mapping & weather population
   - Optimization: Global SS passing and Batch Writing
   ========================================================================== */

function doPost(e) {
  const lock = LockService.getPublicLock();
  try {
    lock.waitLock(5000); 
    const d = JSON.parse(e.postData.contents);
    const ss = SpreadsheetApp.getActive(); 

    /*===============================================================================
      // DEBUG LOGing - Keep this for safety
      const dbg = ss.getSheetByName("debug_ingest") || ss.insertSheet("debug_ingest");
      if (dbg.getLastRow() > 200) dbg.deleteRow(2);
      dbg.appendRow([new Date(), d.source || "", JSON.stringify(d)]);
    ===============================================================================*/

    if (d.source === "kasa") {
      return handleKasaPower(d, ss); 
    } else {
      return handleHousePower(d, ss);
    }
  } catch (f) {
    return ContentService.createTextOutput("Locked").setMimeType(ContentService.MimeType.TEXT);
  } finally {
    SpreadsheetApp.flush(); // Force write before releasing lock
    lock.releaseLock();
  }
}


function handleHourlyLog(d, deviceId, deviceName, sheetName, powerWatts, baseTemp, baseHum, ss) {
  const hourlySheet = ss.getSheetByName(sheetName) || ss.insertSheet(sheetName);
  const props = PropertiesService.getScriptProperties();
  
  // 1. COLUMN MAPPING (Must match your Hardware MACs exactly)
  const COL_MAP = { 
    "house_main": 4, 
    "78:8C:B5:94:C3:AB": 13, // Column M (Water Heater)
    "78:8C:B5:94:C7:1F": 18  // Column R (Dehumidifier)
  };

  const now = new Date(d.time);
  const hourStart = new Date(now); hourStart.setMinutes(0,0,0,0);
  const stateKey = "state_hr_" + deviceId;
  let state = JSON.parse(props.getProperty(stateKey) || "{}");

  // 2. DETECT NEW HOUR AND WRITE PREVIOUS DATA
  if (state.hourKey && state.hourKey !== (deviceId + "_" + hourStart.toISOString())) {
    const tou = getOntarioTOU(new Date(state.hourStartLocal));
    const energyKwh = state.energy_wh / 1000;
    const cost = energyKwh * tou.price;
    const avgW = state.samples > 0 ? (state.power_sum / state.samples) : 0;
    const startCol = COL_MAP[deviceId];

    if (startCol) {
      // Find or Create the Row for this specific hour
      let rowToWrite = -1;
      const lastRow = hourlySheet.getLastRow();
      if (lastRow > 0) {
        const times = hourlySheet.getRange(Math.max(1, lastRow-12), 1, Math.min(13, lastRow), 1).getValues();
        for (let i = 0; i < times.length; i++) {
          if (Math.abs(new Date(times[i][0]).getTime() - new Date(state.hourStartLocal).getTime()) < 1000) {
            rowToWrite = (Math.max(1, lastRow-12)) + i + 1; break;
          }
        }
      }
      
      if (rowToWrite === -1) {
        const newRow = new Array(26).fill(""); 
        newRow[0] = new Date(state.hourStartLocal); 
        newRow[1] = Math.floor(new Date(state.hourStartLocal).getTime()/1000); // UTC Time
        newRow[2] = tou.level; // Rate Level
        hourlySheet.appendRow(newRow);
        rowToWrite = hourlySheet.getLastRow();
      }

      // 3. BATCH WRITE (INCLUDING DT/QUALITY DATA)
      if (deviceId === "house_main") {
        // House Main Block (Cols 4-12): Now includes dt_covered (H) and dt_expected (I)
        hourlySheet.getRange(rowToWrite, startCol, 1, 9).setValues([[
          state.device_name, state.energy_wh, cost, avgW, 
          state.min_power, state.max_power, 
          state.dt_covered, // dt info you wanted back
          (state.freq_sum/state.freq_samples), (state.sig_sum/state.sig_samples)
        ]]);
        // Weather Block
        hourlySheet.getRange(rowToWrite, 23, 1, 4).setValues([[
          (state.temp_sum/state.temp_samples), (state.hum_sum/state.hum_samples), 
          (state.bt_sum/state.bt_samples), (state.bh_sum/state.bh_samples)
        ]]);
      } else {
        // Kasa Blocks (Cols 13-17 or 18-22)
        hourlySheet.getRange(rowToWrite, startCol, 1, 5).setValues([[
          state.device_name, state.energy_wh, cost, avgW, state.max_power
        ]]);
      }
    }
    state = {}; // Clear memory for new hour
  }

  // 4. INCREMENTAL DATA ACCUMULATION (Restore dt Tracking)
  state.hourKey = deviceId + "_" + hourStart.toISOString();
  state.hourStartLocal = hourStart;
  state.device_name = deviceName || deviceId;
  const dt = (now.getTime() - (state.last_ts || now.getTime())) / 1000;
  
  if (dt >= 0 && dt <= 120) {
    state.energy_wh = (state.energy_wh || 0) + powerWatts * (dt / 3600);
    state.dt_covered = (state.dt_covered || 0) + dt; // Restore dt accumulation
    state.power_sum = (state.power_sum || 0) + powerWatts;
    state.samples = (state.samples || 0) + 1;
    // ... (rest of your state accumulation logic)
  }
  state.last_ts = now.getTime();
  props.setProperty(stateKey, JSON.stringify(state));
  return ContentService.createTextOutput("OK").setMimeType(ContentService.MimeType.TEXT);
}


/* ==================================================
   5-MINUTE LOG (BATCH OPTIMIZED)
   ================================================== */
function handle5MinLog(d, deviceId, deviceName, powerWatts, ss) {
  const sheet = ss.getSheetByName("power_5min") || ss.insertSheet("power_5min");
  const props = PropertiesService.getScriptProperties();
  const COL_MAP = { "house_main": 2, "78:8C:B5:94:C3:AB": 5, "78:8C:B5:94:C7:1F": 8 };
  
  const now = new Date(d.time);
  const bucketStart = new Date(Math.floor(now.getTime() / 300000) * 300000);
  const stateKey = "state_5min_" + deviceId;
  let state = JSON.parse(props.getProperty(stateKey) || "{}");

  if (state.bucketKey && state.bucketKey !== (deviceId + "_5min_" + bucketStart.getTime())) {
    const avgPower = state.samples > 0 ? (state.power_sum / state.samples) : 0;
    const startCol = COL_MAP[deviceId];

    if (startCol) {
      let rowToWrite = -1;
      const lastRow = sheet.getLastRow();
      if (lastRow > 1 && Math.abs(new Date(sheet.getRange(lastRow, 1).getValue()).getTime() - state.bucketStartTs) < 1000) rowToWrite = lastRow;

      if (rowToWrite > 0) {
        sheet.getRange(rowToWrite, startCol, 1, 3).setValues([[state.device_name, state.energy_wh, avgPower]]);
        if (deviceId === "house_main") {
           sheet.getRange(rowToWrite, 11, 1, 4).setValues([[(state.temp_sum/state.temp_samples), (state.hum_sum/state.hum_samples), (state.freq_sum/state.freq_samples), (state.sig_sum/state.sig_samples)]]);
        }
      } else {
        const newRow = new Array(14).fill(""); newRow[0] = new Date(state.bucketStartTs);
        newRow[startCol-1] = state.device_name; newRow[startCol] = state.energy_wh; newRow[startCol+1] = avgPower;
        sheet.appendRow(newRow);
      }
    }
    if (sheet.getLastRow() > 600) sheet.deleteRows(2, sheet.getLastRow() - 600);
  }
  state.bucketKey = deviceId + "_5min_" + bucketStart.getTime();
  state.bucketStartTs = bucketStart.getTime();
  state.device_name = deviceName || deviceId;
  state.energy_wh = (state.energy_wh || 0) + powerWatts * ((now.getTime() - (state.last_ts || now.getTime())) / 3600000);
  state.power_sum = (state.power_sum || 0) + powerWatts;
  state.samples = (state.samples || 0) + 1;
  if (d.temp_c) { state.temp_sum = (state.temp_sum || 0) + d.temp_c; state.temp_samples = (state.temp_samples || 0) + 1; }
  if (d.humidity) { state.hum_sum = (state.hum_sum || 0) + d.humidity; state.hum_samples = (state.hum_samples || 0) + 1; }
  if (d.freq) { state.freq_sum = (state.freq_sum || 0) + d.freq; state.freq_samples = (state.freq_samples || 0) + 1; }
  const sig = d.rssi_dbm || d.rssi || d.battery_ok;
  if (sig) { state.sig_sum = (state.sig_sum || 0) + sig; state.sig_samples = (state.sig_samples || 0) + 1; }
  state.last_ts = now.getTime();
  props.setProperty(stateKey, JSON.stringify(state));
}

/* ==================================================
   DAILY SUMMARY LOG (BATCH OPTIMIZED)
   ================================================== */
function handleDailyLog(d, deviceId, deviceName, powerWatts, baseTemp, baseHum, ss) {
  const config = getBillingConfig();
  const sheet = ss.getSheetByName("power_daily") || ss.insertSheet("power_daily");
  const props = PropertiesService.getScriptProperties();
  const COL_MAP = { "house_main": 2, "78:8C:B5:94:C3:AB": 11, "78:8C:B5:94:C7:1F": 17 };

  const now = new Date(d.time);
  const dayStr = now.toLocaleDateString("en-CA");
  const stateKey = "state_day_" + deviceId;
  let state = JSON.parse(props.getProperty(stateKey) || "{}");

  if (state.bucketKey && state.bucketKey !== (deviceId + "_daily_" + dayStr)) {
    const kwhL = state.e_low/3600000; const kwhM = state.e_mid/3600000; const kwhH = state.e_high/3600000;
    const totKwh = kwhL+kwhM+kwhH;
    const sub = (kwhL*config.TOU.LOW) + (kwhM*config.TOU.MID) + (kwhH*config.TOU.HIGH) + (totKwh*config.DELIVERY.VARIABLE_KWH) + (config.DELIVERY.FIXED_MONTHLY/30);
    const cost = sub - (sub * config.REBATE_PCT);
    const startCol = COL_MAP[deviceId];

    if (startCol) {
      let rowToWrite = -1;
      const lastRow = sheet.getLastRow();
      if (lastRow > 0) {
        const dates = sheet.getRange(Math.max(1, lastRow-5), 1, Math.min(6, lastRow), 1).getDisplayValues();
        for (let i=0; i<dates.length; i++) { if (dates[i][0] === state.dayString) { rowToWrite = (Math.max(1, lastRow-5)) + i; break; } }
      }
      if (rowToWrite === -1) { sheet.appendRow([state.dayString]); rowToWrite = sheet.getLastRow(); }

      if (deviceId === "house_main") {
        sheet.getRange(rowToWrite, startCol, 1, 9).setValues([[state.device_name, totKwh, cost, kwhL/1000, kwhM/1000, kwhH/1000, (state.power_sum/state.samples), (state.sig_sum/state.sig_samples), "OK"]]);
        sheet.getRange(rowToWrite, 23, 1, 6).setValues([[(state.temp_sum/state.temp_samples), state.min_t, state.max_t, (state.hum_sum/state.hum_samples), (state.bt_sum/state.bt_samples), (state.bh_sum/state.bh_samples)]]);
      } else {
        const mins = (state.active_s/60).toFixed(0);
        sheet.getRange(rowToWrite, startCol, 1, 6).setValues([[state.device_name, totKwh, cost, mins, "OK", state.max_power]]);
      }
    }
    state = {};
  }

  const tou = getOntarioTOU(now);
  state.bucketKey = deviceId + "_daily_" + dayStr;
  state.dayString = dayStr;
  state.device_name = deviceName || deviceId;
  const dt = (now.getTime() - (state.last_ts || now.getTime())) / 1000;
  const energyWs = powerWatts * dt;
  if (tou.level === "HIGH") state.e_high = (state.e_high || 0) + energyWs;
  else if (tou.level === "MID") state.e_mid = (state.e_mid || 0) + energyWs;
  else state.e_low = (state.e_low || 0) + energyWs;
  
  state.power_sum = (state.power_sum || 0) + powerWatts;
  state.samples = (state.samples || 0) + 1;
  if (powerWatts > 2.0) state.active_s = (state.active_s || 0) + dt;
  state.max_power = Math.max(state.max_power || 0, powerWatts);
  if (d.temp_c) {
    state.temp_sum = (state.temp_sum || 0) + d.temp_c; state.temp_samples = (state.temp_samples || 0) + 1;
    state.min_t = Math.min(state.min_t || 99, d.temp_c); state.max_t = Math.max(state.max_t || -99, d.temp_c);
  }
  if (d.humidity) { state.hum_sum = (state.hum_sum || 0) + d.humidity; state.hum_samples = (state.hum_samples || 0) + 1; }
  if (baseTemp) { state.bt_sum = (state.bt_sum || 0) + Number(baseTemp); state.bt_samples = (state.bt_samples || 0) + 1; }
  if (baseHum) { state.bh_sum = (state.bh_sum || 0) + Number(baseHum); state.bh_samples = (state.bh_samples || 0) + 1; }
  const sig = d.rssi_dbm || d.rssi || d.battery_ok;
  if (sig) { state.sig_sum = (state.sig_sum || 0) + sig; state.sig_samples = (state.sig_samples || 0) + 1; }

  state.last_ts = now.getTime();
  props.setProperty(stateKey, JSON.stringify(state));
}